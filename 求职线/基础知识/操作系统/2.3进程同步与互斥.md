## 进程同步与互斥



### 进程同步

「解决异步问题」**直接制约关系**，源于进程的相互合作，需要协调他们的工作次序。并发性会导致异步。各并发的进程以各自独立的，不可预知的速度向前推进。

eg:管道通信中，写与读并发执行，但是必须按照先写后读的顺序执行。

### 进程互斥

「资源共享」**间接制约关系**

eg:内存或i/o设备



- 互斥共享访问(临界资源 )对临界资源访问必须互斥进行。

    遵循原则:

    1.空闲让进

    2.忙则等待

    3.有限等待，保证有限时间内可以进入临界区(保证不会饥饿)

    4.让权等待，不能进入临界区时应立即释放处理机，防止忙等待

    ```
    //代码结构
    do{
    	entry section;//进入区，检查是否可入，上锁
    	critical section;//临界区，访问临界资源的代码
    	exit section;//退出去，类似解锁
    	remainder section;//剩余操作
    }while(true)
    ```

    

- 同时共享访问



### 进程互斥软件实现方法

1. 单标志法

    算法思想:两个进程访问临界区后将临界区使用权转移至另一个进程。每个进程进入临界区的权限只由另一个进程赋予。 

    设置一个变量标志当前允许进入临界区的进程号，每个进程退出区对这一变量进行修改

    缺点:需要按照某一顺序进入，如果前一进程卡住没有完成进入临界区操作，后续进程全部必须等待。违背空闲让进原则。 

2. 双标志先检查法

    算法思想:维护一个布尔型数组，用各个元素标记各进程想进入临界区的意愿。

    各个进程维护自己数组中所对应的标记。访问临界区时，先检查是否有别的进程在访问，若无则更改自己对应的数组编号，执行访问。

    缺点:有可能违背忙则等待原则。若检查上锁这一操作被打断，可能导致两个进程同时访问临界区 。

3. 双标志后检查法

    算法思想:类似前1算法，同样维护一个布尔型数组，先上锁后检查。

    缺点: 可能产生饥饿，因为上锁与检查仍不是原子操作。产生原因均是由于异步性。

4. Peterson算法

    算法思想:维护希望进入临界区意愿的数组，同时设置一个标志表示当前哪个进程进入临界区。

    算法过程:1.更新数组表达进入临界区意愿。2.可以优先让另一进程进入临界区(turn=进程号)。3.检查进入意愿和进程标志。过程2相当于为谦让过程，实际上谁最后让另一进程则会先进入。

    缺点: 未遵循让权等待原则，会发生忙等，cpu会卡在while循环直至时间片结束。



### 进程互斥的硬件实现方法

**解决检查 上锁操作无法一气呵成的问题**

1. 中断屏蔽方法

    ...

    关中断

    临界区

    开中断

    ...

    缺点:不适用于多处理机;只适用于操作系统内核进程，不适用于用户进程。

2.  TestAndSet指令

    TSL指令通过硬件实现，执行过程不允许被中断，只能一气呵成。该过程将检查和上锁变成原子操作，使用于多处理机。

    缺点:不满足让权等待，会处理器忙等

3.  Swap指令(exchange执行XCHG指令)

    逻辑上同TSL。获取当前lock状态，不论其状态为何值均置位true。上锁与检查变成原子操作。

    缺点:不满足让权等



### **信号量机制**

用户进程通过原语对信号量进行操作，从而方便的实现**进程互斥**和**进程同步**和**前驱关系**。(原语实际上是由关中断/开中断指令实现的)

一对原语:wait(s)原语与signal(S)原语，简写0为P(S)与V(S)，PV操作。S代表信号量是函数调用时的传入参数。

#### 实现进程互斥/解决资源共享问题

互斥本质也可视为资源共享，互斥时一般将初始信号量设置为1。

-    整型信号量

用一个整数型变量作为信号量用于表示系统中某种资源的数量。eg打印机数量为1。

只接受3种操作: 初始化，P操作，V操作(为原语操作)

```
int S = 1;//inition

void wait(int S){//wait 原语
	while (S <= 0);
	S = S - 1;
}

void signal (int S){//signal 原语
	S = S + 1;
}
```

思路：通过原语操作一步完成检查和上锁。解决了并发异步导致的问题。

缺点：不满足让权等待，会发生忙等。



-   记录型信号量

```
typedef struct{
	int value;
	struct process *L;
}semaphore;

void wait(semaphore s){
	s.value--;
	if(s.value < 0){
		block(s.L);//block原语，将进程从运行态变阻塞态，挂到信号量s的等待队列中
	}}
	
void signal(semaphore s){
	s.value++;
	if (s.value <= 0){
		wakeup(s.L);//wakeup原语，将进程唤醒，阻塞态变就绪态。同时将会直接将资源分配给唤醒进程，不需要再次进过wait(P)操作
	}}
```

P(S)，V(S)这对原语对应着对系统资源的申请与书房。

S.value初值代表系统资源某种资源数目。正数代表剩余资源。负数代表有多少进程在等待该系统资源。遵循了让权等待原则不会出现忙等现象。

 **注意**: 

1.  P操作中一定是先S.value++, S操作一定是先S.value--。在可能进行后续操作。
2.  PV操作必须是成对出现的。



#### 实现进程同步

1.  分析何处需要实现进程同步关系，必须保证是一前一后执行2个操作。
2.  设置初始信号量值为0
3.  「**前操作**」**后**执行V(S)操作。增加可用资源
4.  「**后操作**」**前**执行P(S)操作。若有可用资源则可运行。



#### 实现前驱关系

即多层同步问题，每一对前驱关系都是进程同步问题。只要为每一对前驱关系设置一个同步关系即可。

前V后P

![1](C:\Users\wwmyi\OneDrive\notebook\操作系统\2.3进程同步与互斥.assets\image-20200616181603071.png)

### 实例分析过程

1.  关系分析。找出各类进程，确定同步互斥关系
2.  通过操作流程确定PV顺序
3.  设置信号量初值。互斥信号量的一般为1。



#### 生产者-消费者问题

描述:

1.  生产者消费者共享初始空大小为n的缓冲区
2.  缓冲区没满，生产者才能放入产品，否则等待
3.  缓冲区不为空，消费者才能取出产品，否则等待
4.  缓冲区是临界资源，必须互斥访问

思路:

1.  确定进程类型，分析同步互斥关系
    1.  缓冲区满:生产者要等消费者。同步关系
    2.  缓冲区空:消费者要等生产者。同步关系
    3.  缓冲区是一种有限资源，且存取需要互斥。互斥关系+
2.  确定PV操作顺序
3.  设置信号量
    1.  互斥信号量初值一般为1
    2.  同步信号量初值一般为0
    3.  资源信号量初值依照真实值
    4.  本场景中，**两个同步关系设置2个信号量(空闲缓冲区，剩余缓冲区)**，互斥关系设置一个互斥信号量(缓冲区互斥访问)

4.  tips
    1.  实现互斥在同一进程中，PV操作按顺序成对出现。
    2.  **同步P操作需要在互斥P操作前，否则可能导致死锁。(互斥区不写入阻塞代码)**
    3.  V操作不导致阻塞，所以无所谓。
    4.  故尽量互斥操作中不添加同步操作，使其相邻，否则可能会出现死锁。
    5.  非必要代码尽量放在临界区外，这样能尽可能保证临界区利用的高效。(使用完第一时间释放)
    6.  一前一后前V后P

![image-20200616224141268](C:\Users\wwmyi\OneDrive\notebook\操作系统\2.3进程同步与互斥.assets\image-20200616224141268.png)



#### 多生产者-消费者

描述:

1.  大小为1初始为空缓冲区，访问互斥
2.  生产者1生产内容对应消费者1
3.  生产者2生产内容对应消费者2

思路:

1.  缓冲区访问。互斥
2.  生产者1与消费者1。同步

 	3. 生产者2与消费者2。同步
 	4. 缓冲区为空，生产者12可放入产品。同步
 	5. **互斥:临界区前后分PV**
 	6. **同步:前V后P**

tips:

​	1.本题中由于缓冲区大小为1，故其实不设置缓冲区信号量也不会导致同时访问互斥资源。若缓冲区大小大于1则必须设置缓冲区访问信号量。否则会发生同时访问，有可能导致数据覆盖问题。

​	2. 分析同步问题时，应当从**事件角度分析**，而不应由进程行为分析。事件角度:清空缓冲区后可进行生产。进程角度:消费1或消费2取走后，生产1或生产2可放入(这里有4组同步关系，没必要)

 

#### 吸烟者问题

 描述:

1.  三个消费者进程。分别需要材料ABC。
2.  一个生产者进程。可生产材料ABC，每次仅生产一种
3.  缓冲区大小为1，访问互斥。

思路:

确定事件关系

1.  缓冲区为空，生产者才能放入产品。同步
2.  缓冲区访问。互斥
3.  缓冲区有A，消费者1拿 A，同步
4.  缓冲区有B，消费者2拿B，同步
5.  缓冲区有C，消费者3拿C，同步
6.  如果需要使3个消费者轮流取材料，则需要多一个变量

拆分同步与互斥

1.  **互斥:临界区前后分PV**
  2.  **同步:前V后P**

设置信号量

1.  产品A数量 初始0
2.  产品B数量 初始0
3.  产品C数量 初始0
4.  缓冲区为空 初始0
5.  整型变量i 按012循环变化(mod)。

tips:

1.  **因为本题中缓冲区容量为1，所以访问自然是互斥的，故不再需要设置缓冲区的互斥信号量。**
2.  使用变量i完成循环变换，如果是随机，则可以使用一个随机变量。
3.  如果一个生产者生产多个产品(则会有多个前驱事件)，那么各个V操作应放在格子对应「事件」发生之后位置。



#### 读者-写者问题\*\*

描述:

1.  允许多个读者同时对文件执行**读**操作(区别于消费者进程，消费者进程会改变数据或清空数据)
2.  只允许一个写者写信息。
3.  写者执行写操作前，应让已有读者和写者全部退出。
4.  任一写者完成写操作之前不允许其他读写者工作。

写进程和读/写进程不能同时访问缓冲区。

思路:

1.  写进程-写进程、写进程-读进程。相互互斥。
2.  设置互斥信号量rw，写者访问前后PV操作，由于读写进程互斥，所以读进程也进行PV操作。
3.  读写者问题核心: 如何实现两个读者同时访问?
    -   设置count变量，记录有多少个读进程在访问文件
    -   当已有读进程在访问文件，不再进行二次加锁。通过count++记录
    -   读进程访问时先检查count在决定是否加锁; 退出时检查是否是最后一个退出的读进程，如果是则进行V操作解锁。
    -   **问题**: 在并发情况下，对count的检查和赋值有可能不连续执行，会导致某一个读进程被阻塞。
4.  针对count**检查赋值不连续**的问题，增加一个信号量保证对count的互斥访问。

信号量:

1.  rw 用于实现对文件的互斥访问。初始值为1
2.  mutex用于保证对count的互斥访问。初始值为1

*   count变量，记录当前有几个读进程在访问文件



**潜在问题:**

只要有读进程在读，写进程就要阻塞等待，可能会饿死。故该算法中，读进程是优先的。

**针对潜在问题**增加一个信号量用于实现先来先服务(防止写进程饥饿，**读写公平法**)。

3.  w 用于保证(伪)写优先。初始值为1。设置在写进程头尾，与读进程验证count部分读文件开始之前。

**区别**:

-   原读->写->读。读进程锁上文件，写进程被阻塞，第二个读进程可跳过写进程直接读文件。可能导致写进程饥饿。
-   增加信号量w。读进程锁上文件，写进程对w进行P操作，随后被rw阻塞。此时第二个读进程对w进行P操作时会被阻塞(红线处)。实现了写进程优先。

<img src="C:\Users\wwmyi\OneDrive\notebook\操作系统\2.3进程同步与互斥.assets\image-20200626232909415.png" alt="image-20200626232909415" style="zoom:180%;" />



*   写->读->写。当第一个写进程写完文件执行V操作唤醒的是先对w进行P操作的读进程。并没有写优先，仅实现了先来先服务(**读写公平法)**。



tips: 

1.  遇到需要检查赋值连续完成一气呵成的，可以使用互斥信号量实现
2.  count计数器思想。实现多个读
3.  读写公平法内涵。





#### \*\*哲学家进餐问题

![image-20200626234429231](C:\Users\wwmyi\OneDrive\notebook\操作系统\2.3进程同步与互斥.assets\image-20200626234429231.png)

描述:

1.  哲学家仅会思考和进餐。
2.  进餐时需要分别拿起自己**身旁**的两根筷子
3.  关键问题，进程需要多个临界资源导致有死锁的隐患

思路:

1.  5个筷子，相邻的2个哲学家对中间筷子是互斥访问
2.  因为进餐需要2个临界资源才能执行接下来的事情。临界资源分配不当会发生死锁。
3.  定义型号量数组chopstick[5]，对哲学家也编号。编号为i的哲学家左边编号也是i。右边的筷子编号(i+1)%5
4.  **死锁解决方案**
    *   用餐前请求chopstick[i] 与 chopstick[(i+1)%5]。在并发情况下，会发生死锁，都在等待。
        1.  对于哲学家进程限制，最多允许4个人同时进餐，保证至少有一个人是可以拿到2只筷子。(设置一个初始值4的同步信号量)
        2.  要求奇数先左再右，偶数先右再左。保证相邻奇偶哲学家先争抢中间的筷子。争抢到的先执行，另一个进程被阻塞等待。
        3.  仅当哲学家两个筷子均可用才拿。相当于一次拿一双。更准确的说，当某个哲学家拿筷子拿一半被阻塞，别的哲学家不会继续尝试拿筷子，会等待正在进餐的哲学家释放筷子。可能会稍微违背闲时让进但不会产生死锁。拿筷子这件事变为互斥事件。

信号量:

1.  chopstick[5]={1,1,1,1,1}筷子的互斥信号量。

2.  mutex = 1，互斥的进行拿筷子这件事

```
semphore chopstick[5] = {1,1,1,1,1,1};
semaphore mutex = 1; //
Pi(){//i号哲学家的进程
	while(1){
		p(mutex);
		p(chipstick[i]);		//拿左
		p(chipstick[(i+1)%5]);	//拿右
		v(mutex);
		进餐...
		v(chipstick[i]);		//放左
		v(chipstick[(i+1)%5]);	//放右
		思考...
	}
}
```

tips:

1.  当进程有多个临界资源时，可以考虑使用该题三种思路**避免死锁发生**。
    1.  降低进程并发程度，阻止过多程序同时运行
    2.  设定临界资源获取顺序
    3.  将获取临界资源变为完整互斥事件。



### 管程

信号量机制缺点: 实现较复杂，编写程序易出错。出错易发生死锁。

管程**组成**: **一种高级同步机制**，是一种特殊软件模块。类似对class的定义

1.  管程中的**共享数据结构**说明
2.  对于数据结构操作的**一组过程(函数)**
3.  对局部于管程的共享数据设置初始值(**初始化**)

管程特征: 

1.  局部于管程的数据只能被局部于管程的过程(private函数)所访问
2.  进程只有通过调用管程内的过程才能进入管程访问共享数据
3.  每次仅允许**一个进程在管城内执行某个内部过程**  -->对共享数据结构 每次最多只有一个进程在访问。

设计思路:

-   将信号量实现的过程封装了起来，只留下接口

![image-20200627113729654](C:\Users\wwmyi\OneDrive\notebook\操作系统\2.3进程同步与互斥.assets\image-20200627113729654.png)

*   由编译器负责实现进程互斥进入管程的过程。如同时有两个进程申请进入insert，编译器会把第二个进程阻塞。
*   优点: 程序员不需要再管理PV操作，只需要调用接口即可。

tips:

1.  管程中定义共享数据
2.  管程中定义共享数据入口
3.  只能通过特定的入口才能访问共享数据
4.  管程中有多个入口，但每次只能开放其中一个入口，并让某个进程或者线程进入。(**该互斥特性由编译器实现**)同一时间段只有一个进程访问缓冲区
5.  可以在管程中设置**条件变量**与**等待/唤醒**操作解决同步问题。可以设置某个进程/线程在条件变量上等待(此时该进程要释放管程使用权，让出入口);**可以通过唤醒操作将等待在条件变量的进程唤醒。**



**java中，**使用关键字synchronized描述一个函数，那么这个函数同一时间段内只能被一个线程调用。

每次只能有一个线程进入insert，如果多个线程同时调用insert函数，则后来者排队等待。

```java
public synchronized void insert (Item item);
```







